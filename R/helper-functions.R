
#' Assign objects into the global environment
#'
#' @param assign Logical.
#' @param object The object to be assigned.
#' @param name The name of the assigned object.
#'

hlpr_assign <- function(assign, object, name){

  if(base::isTRUE(assign)){

    base::assign(
      x = name,
      value = object,
      envir = .GlobalEnv
    )

  }

}



#' @title Compare samples within an object
#'
#' @description Checks whether the sample column in \code{df}
#' complies with the sample names of the provided object.
#'
#' @param object A valid spata-object.
#' @param df A data.frame
#' @param messages The message vector that is generated by the function in which
#' \code{hlpr_compare_samples()} is called in.
#'
#' @return Updated message vector.
#'
#' @details This function is to be used within the \code{SPATA::validateSpataObject()}-
#' functions. It expands the message-vector that is being generated by the calling
#' function and returns it.

hlpr_compare_samples <- function(object, df, messages){

  df_samples <- stringr::str_c(base::unique(df$sample), collapse = ", ") %>% base::sort()
  o_samples <- stringr::str_c(samples(object), collapse = ", ") %>% base::sort()

  if(!base::identical(df_samples, o_samples)){

    feedback <-
      stringr::str_c("Inavlid samples in column 'sample'.:",
                     "\n In coordinates: ", df_samples,
                     "\n In object:      ", o_samples,
                     sep = "")

    messages <-
      base::append(x = messages,
                   values = feedback)

  }

  return(messages)


}


#' Monocle3 pseudotime accessor
#'
#' @description Loads or compiles a valid cell_data_set-object
#' that fits to the provided spata-object.
#'
#' @param object A valid spata object.
#' @param use_cds_file A directory leading to a .rds file containing a valid
#' cell_data_set-object previously calculated for the specified object. Specified
#' as a character value. If set to FALSE the cell_data_set object will be created
#' from scratch.
#' @param save_cds_file A filename/directory (that does not already exists) under which the used or created cell_data_set-object
#' is going to be stored specified as a character value. Should end with .rds.
#' @param preprocess_method Given to \code{monocle3::preprocess_cds()} if \code{use_cds_file} isn't a character string.
#' @param cluster_method Given to \code{monocle3::cluster_cells()} if \code{use_cds_file} isn't a character string.
#' @param verbose Logical value. If set to TRUE informative messages with respect
#' to the computational progress made will be printed.
#'
#' (Warning messages will always be printed.)
#'
#' @return  A monocle3::cell_data_set object.
#' @export
#'

hlpr_compile_cds <- function(object,
                             use_cds_file = FALSE,
                             save_cds_file = FALSE,
                             preprocess_method = "PCA",
                             cluster_method = c("leiden", "louvain"),
                             verbose = TRUE){


  validation(object)

  if(base::is.character(use_cds_file) & !base::file.exists(use_cds_file)){

    base::stop(stringr::str_c("The specified file in argument 'use_cds_file' does not exist."))

  }

  if(base::is.character(save_cds_file) & base::file.exists(save_cds_file)){

    base::stop(stringr::str_c("The specified filename in argument 'save_cds_file' already exists."))

  }

  if(base::is.character(use_cds_file) &
     base::file.exists(use_cds_file)){

    cds <- base::readRDS(use_cds_file)

    if(!methods::is(object = cds, class2 = "cell_data_set")){

      base::stop(stringr::str_c("File '", use_cds_file, "' is not a valid object of class 'cell_data_set'."))

    }

    barcodes_cds <- base::names(monocle3::pseudotime(cds)) %>% base::sort()
    barcodes_spata <- featureData(object)$barcodes %>% base::sort()

    if(!base::identical(barcodes_cds, barcodes_spata)){

      base::stopp(stringr::str_c("The barcodes of '", use_cds_file, "' and the provided spata-object are not identical."))

    }


  } else {

    if(base::isTRUE(verbose)){base::message("No cds-file specified. Performing monocle anylsis from scratch.")}

    base::stopifnot(preprocess_method %in% c("PCA", "LSI"))
    base::stopifnot(cluster_method %in% c("leiden", "louvain"))

    expression_matrix <- object@data@counts

    gene_metadata <- data.frame(gene_short_name = base::rownames(expression_matrix))
    base::rownames(gene_metadata) <- base::rownames(expression_matrix)

    cell_metadata <- data.frame(object@fdata)
    base::rownames(cell_metadata) <- object@fdata$barcodes

    cds <- monocle3::new_cell_data_set(
      expression_matrix,
      cell_metadata = cell_metadata,
      gene_metadata = gene_metadata)

    cds <- cds[,Matrix::colSums(exprs(cds)) != 0]

    if(base::isTRUE(verbose)){base::message("Estimating size factors...")}
    cds <- monocle3::estimate_size_factors(cds)

    if(base::isTRUE(verbose)){base::message("Preprocessing cell data set...")}
    cds <- monocle3::preprocess_cds(cds, preprocess_method = preprocess_method, num_dim = 30)

    if(base::isTRUE(verbose)){base::message("Reducing dimensions...")}
    cds <- monocle3::reduce_dimension(cds, cores=4)

    if(base::isTRUE(verbose)){base::message("Clustering cells...")}
    cds <- monocle3::cluster_cells(cds, cluster_method = cluster_method)

    if(base::isTRUE(verbose)){base::message("Learning trajectory...")}
    cds <- monocle3::learn_graph(cds)

  }

  if(base::isTRUE(verbose)){base::message("Ordering cells...")}
  cds <- monocle3::order_cells(cds)


  # save cds file if save_cds_file is specified as a character
  if(base::is.character(save_cds_file)){

    if(base::isTRUE(verbose)){

      base::message(stringr::str_c("Saving cell data set object 'cds' as under directory: '", save_cds_file, "'"))

    }

    base::saveRDS(cds, file = save_cds_file)

  }

  base::return(cds)

}


#' @title Compiles a trajectory data.frame
#'
#' @param segment_trajectory_df A data.frame specifying each segment of the whole
#' trajectory with variables \code{x, y, xend, yend}.
#' @param trajectory_width Numeric value that determines the width of the
#' trajectory.
#' @param object A valid spata-object.
#' @param sample The sample specified as a character string of length one.
#'
#' @return A data.frame containing the variables \emph{barcodes, sample, x, y}
#' as well as
#' \itemize{
#'  \item{\emph{projection_length}: indicating the position of every barcode-spot
#'  with respect to the direction of the trajectory-part. The higher the barcode-spots
#'  value is the farther away it is from the starting point of the trajectory-part
#'  it belongs to. }
#'  \item{\emph{trajectory_part}: indicating the part of the trajectory the barcode-spot
#'   belongs to.}
#'   }
#'
#' @export

hlpr_compile_trajectory <- function(segment_trajectory_df,
                                    trajectory_width,
                                    object,
                                    sample){

  validation(object)

  all_trajectories_list <- list()

  for(i in 1:base::nrow(segment_trajectory_df)){

    # One dimensional part ----------------------------------------------------

    trajectory_vector_df <- segment_trajectory_df[i,1:4]

    start_point <- as.numeric(trajectory_vector_df[1:2])
    end_point <- as.numeric(trajectory_vector_df[3:4])

    trajectory_vec <- end_point - start_point

    # factor with which to compute the width vector
    trajectory_magnitude <- base::sqrt((trajectory_vec[1])^2 + (trajectory_vec[2])^2)
    trajectory_factor <- trajectory_width / trajectory_magnitude

    # orthogonal trajectory vector
    orth_trajectory_vec <- (c(-trajectory_vec[2], trajectory_vec[1]) * trajectory_factor)


    # Two dimensional part ----------------------------------------------------

    # determine trajectory frame points 'tfps' making up the square that embraces
    # the points
    tfp1.1 <- start_point + orth_trajectory_vec
    tfp1.2 <- start_point - orth_trajectory_vec
    tfp2.1 <- end_point - orth_trajectory_vec
    tfp2.2 <- end_point + orth_trajectory_vec

    trajectory_frame <-
      data.frame(
        x = c(tfp1.1[1], tfp1.2[1], tfp2.1[1], tfp2.2[1]),
        y = c(tfp1.1[2], tfp1.2[2], tfp2.1[2], tfp2.2[2])
      )

    # calculate every point of interests projection on the trajectory vector using 'vector projection'  on a local
    # coordinate system 'lcs' to sort the points according to the trajectories direction

    sample_coords <-
      coordsSpatial(object = object, of_sample = sample)

    lcs <- data.frame(
      x = c(tfp1.1[1], tfp1.1[1]),
      y = c(tfp1.1[2], tfp1.1[2]),
      xend = c(tfp2.2[1], tfp1.2[1]),
      yend = c(tfp2.2[2], tfp1.2[2]),
      id = c("local length axis", "local width axis")
    )

    positions <- sp::point.in.polygon(point.x = sample_coords$x,
                                      point.y = sample_coords$y,
                                      pol.x = trajectory_frame$x,
                                      pol.y = trajectory_frame$y)


    # Data wrangling part -----------------------------------------------------

    # points of interest data.frame
    points_of_interest <-
      sample_coords %>%
      dplyr::mutate(position = positions) %>%
      dplyr::filter(position != 0) %>% # filter only those that fall in the trajectory frame
      dplyr::select(-position) %>%
      dplyr::group_by(barcodes) %>%
      dplyr::mutate(projection_length = hlpr_vector_projection(lcs = lcs, x, y),
                    trajectory_part = stringr::str_c("Part", i, sep = " ")) %>%
      dplyr::arrange(projection_length) # arrange barcodes according to their projection value


    all_trajectories_list[[i]] <- points_of_interest

  }

  compiled_trajectory_df <- base::do.call(base::rbind, all_trajectories_list)

  return(compiled_trajectory_df)

}

#' Removes the class part of a gene set string
#'
#' @param string Gene sets as a character vector
#'
#' @return Gene set name
#'

hlpr_gene_set_name <- function(string){

  stringr::str_remove(string = string, pattern = "^.+?_")

}


#' @title Provides the image as ggplot background
#'
#' @inherit check_sample params
#' @param image Image input.
#' @param display_image Logical value.
#'
#' @return Either null or a ggplot2::geom_annotation_raster
#'
#' @export

hlpr_image_add_on <- function(image){

  if(!base::is.null(image)){

    if(!"Image" %in% base::class(image)){

      base::warning("Argument 'image' is neither NULL nor an object of class 'Image'. ")
      image_add_on <- NULL

    } else {

      image_raster <- grDevices::as.raster(image)

      image_info <-
        magick::image_read(image_raster) %>%
        magick::image_info()

      image_flipped <-
        magick::image_read(image_raster) %>%
        magick::image_flip()

      image_add_on <-
        ggplot2::annotation_raster(raster = image_flipped,
                                   xmin = 0, ymin = 0,
                                   xmax = image_info$width,
                                   ymax = image_info$height)

    }

  }

}

#' @rdname hlpr_image_add_on
#' @export
hlpr_image_add_on2 <- function(object, display_image, of_sample){

  # set up background
  if(base::isTRUE(display_image)){

    image_raster <-
      image(object, of_sample) %>%
      grDevices::as.raster()

    img_info <-
      image_raster %>%
      magick::image_read() %>%
      magick::image_info()

    st_image <-
      image_raster %>%
      magick::image_read() %>%
      magick::image_flip()

    image_add_on <-
      ggplot2::annotation_raster(raster = st_image,
                                 xmin = 0, ymin = 0,
                                 xmax = img_info$width,
                                 ymax = img_info$height)

  } else {

    image_add_on <- NULL

  }



}


#' @title Return customized ggplot:labs()
#'
#' @description Helper function
#'
#' @param input The color_to argument
#' @param input_str Title-prefix. Should be one of \emph{'Genes:', 'Gene set:'} or \code{'Feature:'}.
#' @param color_str Legend title
#' @param display_title Logical. If set to FALSE only the legend-title will be specified.
#'
#' @return A customized \code{ggplot2::labs()}-function.
#' @export

hlpr_labs_add_on <- function(input,
                             input_str,
                             color_str,
                             display_title){

  if(base::isTRUE(display_title)){

    if(base::length(input) > 5){

      input <- c(input[1:5], stringr::str_c("... +", (length(input)-5), sep = " "))

    }

    input_clpsd <- stringr::str_c(input, collapse = ", ")

    plot_title <- stringr::str_c(input_str, input_clpsd, sep = " ")

    base::return(ggplot2::labs(title = plot_title, color = color_str))

  } else {

    base::return(ggplot2::labs(color = color_str))

  }

}



#' @title Trajectory - Linear model
#'
#' @description To be used in \code{rankTrajectoryGenes()} or
#' in \code{rankTrajectoryGenes()} as input for \code{.f}-argument in
#' \code{purrr::map()}. Models the expression of the respective
#' gene set expression values along the trajectory order of
#' the provided data.frame.
#'
#' @param df A trajectory data.frame that was generated by
#' \code{hlpr_summarize_trajectory_df()}.
#'
#' @return A liner model.
#' @export

hlpr_lm_trajectory <- function(df){

  stats::lm(formula = values ~ trajectory_order, data = df)

}



#' @title Linear model summary
#'
#' @description Takes a linear model and returns an assembled data.frame
#' of one row containing information about the models slope, adjusted Rsquared
#' and pvalue.
#'
#' @param lm A linear model object.
#'
#' @return A data.frame of one row.
#' @export

hlpr_lm_info <- function(model){

  glance_df <- broom::glance(x = model)
  tidy_df <-
    broom::tidy(x = model) %>%
    dplyr::filter(term == "trajectory_order") %>%
    dplyr::select(estimate)

  lm_info <-
    base::cbind(glance_df, tidy_df) %>%
    dplyr::select(
      lm_estimate = estimate,
      lm_adj_rsquared = adj.r.squared,
      lm_pvalue = p.value
    )

  base::return(lm_info)

}



#' @title Normalize gene or gene set values
#'
#' @description Helper function to use within \code{purrr::imap()}
#'
#' @param variable The variable to smooth (if matches requirements).
#' @param var_name The name of the variable to smooth.
#' @param verbose Logical
#' @param aspect Gene or Gene set
#' @param subset A character vector of variable names that are to be normalized
#'
#' @return A normalized variable (data.frame within \code{purrr::imap()})
#'

hlpr_normalize_imap <- function(variable,
                                var_name,
                                verbose = TRUE,
                                aspect,
                                subset){


  if(!base::is.numeric(variable) | !var_name %in% subset){

      base::return(variable)

  } else if(base::all(variable == 0)){

      if(var_name == "mean_genes"){

        var_name <- "average"

      }

      base::warning(stringr::str_c(aspect, var_name, "contains only 0s. Returning NULL.", sep = " "))
      base::return(NULL)

  } else if(base::length(base::unique(variable)) == 1){

      if(var_name == "mean_genes"){

        var_name <- "average"

      }

      base::warning(stringr::str_c(aspect, var_name, "is uniformly expressed. Returning NULL.", sep = " "))
      base::return(NULL)

  } else {

      # normalize variable
      res <-
        (variable - base::min(variable)) /
        (base::max(variable) - base::min(variable))

      if(!base::any(base::is.na(res))){

       if(verbose){

         if(var_name == "mean_genes"){

           var_name <- "average"

         }

          base::message(stringr::str_c(aspect,  var_name, "successfully normalized.", sep = " "))

       }

      base::return(res)

      } else {

        base::warning(stringr::str_c(aspect, var_name, "normalization resulted in NaNs. Returning NULL.", sep = " "))
        base::return(NULL)

      }

  }

}



#' @inherit hlpr_normalize_imap params title
#'
#' @return A normalized variable

hlpr_normalize_vctr <- function(variable){

  res <-
    (variable - base::min(variable)) /
    (base::max(variable) - base::min(variable))

  if(base::any(base::is.na(res))){

    base::return(variable)

  } else {

    base::return(res)

  }


}



#' @title Smooth variables spatially
#'
#' @description Helper function to use within \code{purrr::imap()}
#'
#' @param variable The variable to smooth
#' @param var_name Name of the variable to smooth
#' @param coords_df Data.frame that contains x and y coordinates
#' @param verbose Logical
#' @param smooth_span Span to smooth with
#' @param aspect Gene or Gene set
#' @param subset Vector of variable names to smooth
#'
#' @return Smoothed variable (data.frame within \code{purrr::imap()})

hlpr_smooth <- function(variable,
                        var_name,
                        coords_df,
                        verbose = TRUE,
                        smooth_span,
                        aspect,
                        subset){

  data <-
    base::cbind(variable, coords_df[, c("x", "y")]) %>%
    magrittr::set_colnames(value = c("rv", "x", "y"))

  if(!var_name %in% subset){

    base::return(variable)

  } else if(!base::is.numeric(data$rv)){

    if(var_name == "mean_genes"){

      var_name <- "average"

    }

    base::warning("Skip smoothing of ", aspect, " ", var_name, " as it is of class '", base::class(dplyr::pull(data, rv)), "'.")
    base::return(variable)

  } else if(base::any(base::is.na(data$rv)) |
            base::any(base::is.nan(data$rv))|
            base::any(base::is.infinite(data$rv))){

    if(var_name == "mean_genes"){

      var_name <- "average"

    }

    base::warning(stringr::str_c("Skip smoothing of", aspect, var_name, "as it contains NaNs or infinites.", sep = " "))
    base::return(variable)

  } else {

    if(base::isTRUE(verbose)){

      if(var_name == "mean_genes"){

        var_name <- "average"

      }

      base::message(stringr::str_c("Smoothing ", aspect, " ", var_name, " with span ", smooth_span, ".", sep = ""))

    }

    model <- stats::loess(formula = rv ~ x * y, data = data, span = smooth_span)

    return(stats::predict(object = model))

  }

}


#' @title Smooth variable spatially in mini-shiny-apps
#'
#' @description Helper function to use independently (or in a pipe)
#'
#' @inherit hlpr_smooth params
#'
#' @return Data.frame with the smoothed variable specified in \code{variable}.
#'
hlpr_smooth_shiny <- function(variable,
                              coords_df,
                              smooth_span){

  base::colnames(coords_df)[base::which(base::colnames(coords_df) == variable)] <- "response_variable"

  if(base::is.numeric(coords_df$response_variable)){

    model <- stats::loess(formula = response_variable ~ x * y, span = smooth_span, data = coords_df)

    smoothed_df_prel <-
      broom::augment(model) %>%
      dplyr::select(x, y, .fitted) %>%
      magrittr::set_colnames(value = c("x", "y", variable))

    selected_df <- dplyr::select(coords_df, -c("x", "y", "response_variable"))

    smoothed_df <-
      base::cbind(smoothed_df_prel, selected_df) %>%
      dplyr::select(barcodes, sample, x, y, dplyr::everything()) %>%
      as.data.frame()


    # if coords_df derived from trajectory analysis
    if("trajectory_order" %in% base::colnames(coords_df)){

      smoothed_df$trajectory_order <- coords_df$trajectory_order

    }

    if(base::nrow(smoothed_df) == base::nrow(coords_df)){

      return(smoothed_df)

    } else {

      shiny::showNotification(ui = "Smoothing failed. Return original values.",
                              type = "warning")

      return(coords_df)

    }


  } else {

    shiny::showNotification(ui = "Can not smooth features that aren't of class 'numeric'. Skip smoothing.",
                            type = "warning")

    base::colnames(coords_df)[base::which(base::colnames(coords_df) == "response_variable")] <- variable

    return(coords_df)

  }

}



#' @title Summarize and join ctdf
#'
#' @description Joins a compiled trajectory data.frame with
#' the desired information and summarizes it's joined values
#' along the sub-trajectory-parts via \code{base::mean()}.
#'
#' @inherit check_object params
#' @inherit check_compiled_trajectory_df params
#' @inherit check_variables params
#' @inherit check_method params
#' @inherit verbose params
#' @inherit normalize params
#' @param accuracy Numeric. Given to \code{accuracy}-argument of
#' \code{plyr::round_any()}. Determines how many barcode-spots will be summarized
#' as one sub-trajectory-part.
#'
#' @export

hlpr_summarize_trajectory_df <- function(object,
                                         ctdf,
                                         accuracy = 5,
                                         variables,
                                         method_gs = "mean",
                                         verbose = TRUE,
                                         normalize = FALSE){


  # 1. Control --------------------------------------------------------------

  # lazy check
  check_object(object)
  check_compiled_trajectory_df(ctdf = ctdf)

  stopifnot(base::is.numeric(accuracy))
  stopifnot(base::is.character(variables))
  stopifnot(base::is.logical(verbose))

  # adjusting check

  variables <- check_variables(variables = variables,
                               all_features = getFeatureNames(object),
                               all_gene_sets = getGeneSets(object),
                               all_genes = getGenes(object),
                               max_slots = 1,
                               max_length = Inf)

  if(base::names(variables) == "features"){

    variables[[1]] <- check_features(object = object,
                                     features = variables[[1]],
                                     valid_classes = c("numeric", "integer"))

  }

  # -----

  # 2. Summarize and join compiled trajectory data.frame --------------------

  # join data.frame with variables
  joined_df <-
    dplyr::mutate(.data = ctdf,
                  order_binned = plyr::round_any(x = projection_length,
                                                 accuracy = accuracy,
                                                 f = base::floor)) %>%
    joinWithVariables(object = object,
                      coords_df = .,
                      variables = variables,
                      method_gs = method_gs,
                      average_genes = FALSE,
                      smooth = FALSE,
                      normalize = normalize,
                      verbose = verbose)

  # keep only variables that were successfully joined
  variables[[1]] <- variables[[1]][variables[[1]] %in% base::colnames(joined_df)]

  # summarize data.frame
  if(base::isTRUE(verbose)){base::message("Summarizing trajectory data.frame...")}

  summarized_df <-
    dplyr::group_by(.data = joined_df, trajectory_part, order_binned) %>%
    dplyr::summarise(dplyr::across(.cols = dplyr::all_of(x = variables[[1]]),
                                   .fns = ~ mean(., na.rm = TRUE)),
                     .groups = "drop_last") %>%
    dplyr::mutate(trajectory_part_order = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(trajectory_order = dplyr::row_number()) %>%
    tidyr::pivot_longer(cols = dplyr::all_of(x = variables[[1]]),
                        names_to = base::names(variables),
                        values_to = "values")

  # -----

  base::return(summarized_df)

}

#' @title Perform vector projection
#'
#' @description Helper function for trajectory-analysis to use within
#' \code{dplyr::mutate()}. Performs vector-projection with a spatial position
#' and a local coordinates system to arrange the barcodes that fall into a
#' trajectory square according to the trajectory direction.
#'
#' @param lcs A data.frame specifying the local coordinates system with variables
#' \code{x, y, xend, yend} and the observations \emph{local length axis} and
#' \emph{local width axis}.
#' @param x_coordinate x-coordinate
#' @param y_coordinate y-coordinate
#'
#' @return The projected length.
#'
#' @export

hlpr_vector_projection <- function(lcs, x_coordinate, y_coordinate){

  # vector from point of interest to origin of local coord system: 'vto'
  vto <- c((x_coordinate - lcs$x[1]), (y_coordinate - lcs$y[1]))

  # define local length axis (= relocated trajectory): 'lla'
  lla <- c((lcs$xend[1] - lcs$x[1]), (lcs$yend[1] - lcs$y[1]))

  # define lambda coefficient
  lambda <-
    ((vto[1] * lla[1]) + (vto[2] * lla[2])) / base::sqrt((lla[1])^2 + (lla[2])^2)^2

  # projecting vector on length axis
  pv <- lambda * (lla)

  # compute the length of the projected vector
  res <- base::sqrt((pv[1])^2 + (pv[2])^2)

  base::return(res)


}



#' @title Widen trajectory data.frame
#'
#' @param stdf A summarized trajectory data.frame - output
#' from \code{hlpr_summarize_trajectory_df()}.
#' @param variable Character value. The variable of \code{stdf}:
#' \emph{'gene_sets', 'genes'} or \emph{'features'}.
#'
#'
#' @return A widened data.frame in which each every observation is a
#' trajectory and every variable describes the value of the trajectory
#' at a specific position.
#'
#' @export
#'

hlpr_widen_trajectory_df <- function(stdf,
                                     variable){

  tidyr::pivot_wider(data = tdf,
                     id_cols = dplyr::all_of(c("trajectory_order", variable)),
                     names_from = dplyr::all_of(c("trajectory_part", "trajectory_order")),
                     values_from = "values")


}







